import asyncio
import os
import re
import shutil
from dataclasses import dataclass, field
from pathlib import Path

from app.config import settings


@dataclass
class CompileResult:
    success: bool = False
    pdf_path: str = ""
    log: str = ""
    errors: list[str] = field(default_factory=list)


_UNICODE_REPLACEMENTS = {
    "≥": r"$\geq$",
    "≤": r"$\leq$",
    "≠": r"$\neq$",
    "±": r"$\pm$",
    "×": r"$\times$",
    "÷": r"$\div$",
    "∞": r"$\infty$",
    "√": r"$\sqrt{}$",
    "α": r"$\alpha$",
    "β": r"$\beta$",
    "γ": r"$\gamma$",
    "δ": r"$\delta$",
    "θ": r"$\theta$",
    "λ": r"$\lambda$",
    "μ": r"$\mu$",
    "π": r"$\pi$",
    "σ": r"$\sigma$",
    "φ": r"$\varphi$",
    "ω": r"$\omega$",
    "°": r"$^\circ$",
    "²": r"$^2$",
    "³": r"$^3$",
    "⁻": r"$^-$",
    "⁷": r"$^7$",
    "₂": r"$_2$",
    "₃": r"$_3$",
    "→": r"$\rightarrow$",
    "←": r"$\leftarrow$",
    "↔": r"$\leftrightarrow$",
    "…": r"\ldots{}",
    "—": r"---",
    "–": r"--",
    "'": "`",
    "\u2019": "'",
    "\u201c": "``",
    "\u201d": "''",
}


def _fix_common_latex_issues(content: str) -> str:
    """Fix common LaTeX issues generated by LLM before compilation."""
    # Replace Unicode characters that LaTeX fonts don't support.
    # Only replace outside of math mode (rough heuristic: skip $ ... $ regions).
    # For simplicity, replace globally — the math-mode wrapping ($...$) is safe
    # even if the character was already inside math.
    for char, replacement in _UNICODE_REPLACEMENTS.items():
        content = content.replace(char, replacement)

    # Fix undefined math commands LLMs commonly generate
    _UNDEFINED_COMMANDS = {
        r"\arcsec": r"\mathrm{arcsec}",
        r"\arcmin": r"\mathrm{arcmin}",
        r"\dB": r"\mathrm{dB}",
        r"\Hz": r"\mathrm{Hz}",
        r"\kHz": r"\mathrm{kHz}",
        r"\MHz": r"\mathrm{MHz}",
        r"\GHz": r"\mathrm{GHz}",
    }
    for cmd, repl in _UNDEFINED_COMMANDS.items():
        content = content.replace(cmd, repl)

    # Fix enumitem shortlabel: \begin{enumerate}[a)] -> \begin{enumerate}[label=\alph*)]
    content = re.sub(
        r'\\begin\{enumerate\}\[a\)\]',
        r'\\begin{enumerate}[label=\\alph*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[A\)\]',
        r'\\begin{enumerate}[label=\\Alph*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[i\)\]',
        r'\\begin{enumerate}[label=\\roman*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[I\)\]',
        r'\\begin{enumerate}[label=\\Roman*)]',
        content,
    )
    # Fix \begin{enumerate}[1)] and similar
    content = re.sub(
        r'\\begin\{enumerate\}\[1\)\]',
        r'\\begin{enumerate}[label=\\arabic*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[1\.\]',
        r'\\begin{enumerate}[label=\\arabic*.]',
        content,
    )

    # Fix \centering inside tabularx X columns: \centering redefines \\
    # to \newline, which breaks \hline after \\. Add \arraybackslash to
    # restore \\ as row-end. Only apply inside tabularx environments.
    content = _fix_centering_in_tabularx(content)

    # Fix "There's no line here to end": font-only group followed by \\
    # e.g. {\fontsize{...}\selectfont\heiti\bfseries }\\[1em]
    # When Jinja2 variables render empty, only font commands remain.
    # Insert ~ before closing } so \\ has content to end.
    content = re.sub(
        r'(\\(?:bfseries|normalfont|itshape|mdseries|selectfont|heiti|songti|fangsong|kaiti))\s*\}(\\\\)',
        r'\1~}\2',
        content,
    )

    # Fix truncated LaTeX: close unclosed environments and ensure \end{document}
    content = _fix_truncated_latex(content)

    return content


def _fix_centering_in_tabularx(content: str) -> str:
    """Fix \\centering inside tabularx that breaks \\\\ row endings.

    In tabularx X columns (paragraph mode), \\centering redefines \\\\ to
    \\newline instead of \\tabularnewline, causing 'Misplaced \\noalign'
    errors when \\hline follows. Fix by appending \\arraybackslash after
    \\centering inside tabularx environments.
    """
    def fix_tabularx_block(m: re.Match) -> str:
        block = m.group(0)
        # Add \arraybackslash after bare \centering (not already followed by it)
        block = re.sub(
            r'\\centering(?!\\arraybackslash)',
            r'\\centering\\arraybackslash',
            block,
        )
        return block

    content = re.sub(
        r'\\begin\{tabularx\}.*?\\end\{tabularx\}',
        fix_tabularx_block,
        content,
        flags=re.DOTALL,
    )
    return content


def _fix_truncated_latex(content: str) -> str:
    """Detect and repair truncated LaTeX output from LLM."""
    # Track open environments
    open_envs: list[str] = []
    for m in re.finditer(r'\\(begin|end)\{([^}]+)\}', content):
        action, env_name = m.group(1), m.group(2)
        if action == 'begin':
            open_envs.append(env_name)
        elif action == 'end' and open_envs and open_envs[-1] == env_name:
            open_envs.pop()

    # If there are unclosed environments, close them in reverse order
    if open_envs:
        # Remove 'document' from the list — we'll handle it separately
        has_document = False
        closings = []
        for env in reversed(open_envs):
            if env == 'document':
                has_document = True
            else:
                closings.append(f'\\end{{{env}}}')

        if closings:
            content = content.rstrip() + '\n' + '\n'.join(closings) + '\n'

        # Ensure \end{document} is present
        if has_document and '\\end{document}' not in content:
            content = content.rstrip() + '\n\\end{document}\n'
    elif '\\begin{document}' in content and '\\end{document}' not in content:
        content = content.rstrip() + '\n\\end{document}\n'

    return content


def _copy_support_dirs(support_dirs: list[Path], target_dir: Path) -> None:
    """Copy support directories (cls/sty/bst etc.) into the compilation target."""
    for src_dir in support_dirs:
        dst = target_dir / src_dir.name
        if dst.exists():
            shutil.rmtree(dst)
        shutil.copytree(src_dir, dst)


async def compile_latex(
    latex_content: str,
    output_dir: Path,
    support_dirs: list[Path] | None = None,
) -> CompileResult:
    """Compile LaTeX content to PDF using latexmk + xelatex."""
    output_dir.mkdir(parents=True, exist_ok=True)
    if support_dirs:
        _copy_support_dirs(support_dirs, output_dir)
    latex_content = _fix_common_latex_issues(latex_content)
    tex_path = output_dir / "document.tex"
    tex_path.write_text(latex_content, encoding="utf-8")

    env = {**os.environ, "PATH": f"/Library/TeX/texbin:{os.environ.get('PATH', '')}"}

    try:
        process = await asyncio.create_subprocess_exec(
            settings.LATEX_CMD,
            "-xelatex",
            "-interaction=nonstopmode",
            "-no-shell-escape",
            "document.tex",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=str(output_dir),
            env=env,
        )
        stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=60)

        log_text = stdout.decode("utf-8", errors="replace")
        err_text = stderr.decode("utf-8", errors="replace")
        full_log = log_text + "\n" + err_text

        pdf_path = output_dir / "document.pdf"
        if pdf_path.exists():
            return CompileResult(
                success=True,
                pdf_path=str(pdf_path),
                log=full_log,
            )
        else:
            errors = _extract_errors(full_log)
            return CompileResult(
                success=False,
                log=full_log,
                errors=errors if errors else ["PDF file was not generated."],
            )

    except asyncio.TimeoutError:
        return CompileResult(
            success=False,
            log="Compilation timed out after 60 seconds.",
            errors=["Compilation timed out."],
        )
    except FileNotFoundError:
        return CompileResult(
            success=False,
            log=f"Command '{settings.LATEX_CMD}' not found.",
            errors=[f"LaTeX compiler '{settings.LATEX_CMD}' is not installed or not in PATH."],
        )


async def validate_latex_syntax(
    latex_content: str,
    support_dirs: list[Path] | None = None,
) -> CompileResult:
    """Quick syntax validation using xelatex -draftmode (no PDF output).

    Much faster than full compilation — only checks syntax without generating
    any output file. Used to validate individual chapters before assembly.
    """
    import tempfile

    work_dir = Path(tempfile.mkdtemp(prefix="latex_validate_"))

    try:
        if support_dirs:
            _copy_support_dirs(support_dirs, work_dir)
        latex_content = _fix_common_latex_issues(latex_content)
        tex_path = work_dir / "validate.tex"
        tex_path.write_text(latex_content, encoding="utf-8")

        env = {**os.environ, "PATH": f"/Library/TeX/texbin:{os.environ.get('PATH', '')}"}

        try:
            process = await asyncio.create_subprocess_exec(
                "xelatex",
                "-draftmode",
                "-interaction=nonstopmode",
                "-no-shell-escape",
                "-halt-on-error",
                "validate.tex",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(work_dir),
                env=env,
            )
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=30
            )

            log_text = stdout.decode("utf-8", errors="replace")
            err_text = stderr.decode("utf-8", errors="replace")
            full_log = log_text + "\n" + err_text

            errors = _extract_errors(full_log)
            return CompileResult(
                success=process.returncode == 0,
                log=full_log,
                errors=errors,
            )
        except asyncio.TimeoutError:
            return CompileResult(
                success=False,
                log="Validation timed out after 30 seconds.",
                errors=["Validation timed out."],
            )
        except FileNotFoundError:
            return CompileResult(
                success=False,
                log="xelatex not found.",
                errors=["xelatex is not installed or not in PATH."],
            )
    finally:
        shutil.rmtree(work_dir, ignore_errors=True)


def _extract_errors(log: str) -> list[str]:
    errors = []
    for line in log.split("\n"):
        if line.startswith("!") or "Error" in line:
            errors.append(line.strip())
    return errors

import asyncio
import logging
import os
import platform
import re
import shutil
import subprocess
from dataclasses import dataclass, field
from pathlib import Path

from app.config import settings

logger = logging.getLogger(__name__)


@dataclass
class CompileResult:
    success: bool = False
    pdf_path: str = ""
    log: str = ""
    errors: list[str] = field(default_factory=list)


_UNICODE_REPLACEMENTS = {
    "≥": r"$\geq$",
    "≤": r"$\leq$",
    "≠": r"$\neq$",
    "±": r"$\pm$",
    "×": r"$\times$",
    "÷": r"$\div$",
    "∞": r"$\infty$",
    "√": r"$\sqrt{}$",
    "α": r"$\alpha$",
    "β": r"$\beta$",
    "γ": r"$\gamma$",
    "δ": r"$\delta$",
    "θ": r"$\theta$",
    "λ": r"$\lambda$",
    "μ": r"$\mu$",
    "π": r"$\pi$",
    "σ": r"$\sigma$",
    "φ": r"$\varphi$",
    "ω": r"$\omega$",
    "°": r"$^\circ$",
    "²": r"$^2$",
    "³": r"$^3$",
    "⁻": r"$^-$",
    "⁷": r"$^7$",
    "₂": r"$_2$",
    "₃": r"$_3$",
    "→": r"$\rightarrow$",
    "←": r"$\leftarrow$",
    "↔": r"$\leftrightarrow$",
    "…": r"\ldots{}",
    "—": r"---",
    "–": r"--",
    "'": "`",
    "\u2019": "'",
    "\u201c": "``",
    "\u201d": "''",
}


def _fix_common_latex_issues(content: str) -> str:
    """Fix common LaTeX issues generated by LLM before compilation."""
    # Replace Unicode characters that LaTeX fonts don't support.
    # Only replace outside of math mode (rough heuristic: skip $ ... $ regions).
    # For simplicity, replace globally — the math-mode wrapping ($...$) is safe
    # even if the character was already inside math.
    for char, replacement in _UNICODE_REPLACEMENTS.items():
        content = content.replace(char, replacement)

    # Fix undefined math commands LLMs commonly generate
    _UNDEFINED_COMMANDS = {
        r"\arcsec": r"\mathrm{arcsec}",
        r"\arcmin": r"\mathrm{arcmin}",
        r"\dB": r"\mathrm{dB}",
        r"\Hz": r"\mathrm{Hz}",
        r"\kHz": r"\mathrm{kHz}",
        r"\MHz": r"\mathrm{MHz}",
        r"\GHz": r"\mathrm{GHz}",
    }
    for cmd, repl in _UNDEFINED_COMMANDS.items():
        content = content.replace(cmd, repl)

    # Fix enumitem shortlabel: \begin{enumerate}[a)] -> \begin{enumerate}[label=\alph*)]
    content = re.sub(
        r'\\begin\{enumerate\}\[a\)\]',
        r'\\begin{enumerate}[label=\\alph*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[A\)\]',
        r'\\begin{enumerate}[label=\\Alph*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[i\)\]',
        r'\\begin{enumerate}[label=\\roman*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[I\)\]',
        r'\\begin{enumerate}[label=\\Roman*)]',
        content,
    )
    # Fix \begin{enumerate}[1)] and similar
    content = re.sub(
        r'\\begin\{enumerate\}\[1\)\]',
        r'\\begin{enumerate}[label=\\arabic*)]',
        content,
    )
    content = re.sub(
        r'\\begin\{enumerate\}\[1\.\]',
        r'\\begin{enumerate}[label=\\arabic*.]',
        content,
    )

    # Fix \centering inside tabularx X columns: \centering redefines \\
    # to \newline, which breaks \hline after \\. Add \arraybackslash to
    # restore \\ as row-end. Only apply inside tabularx environments.
    content = _fix_centering_in_tabularx(content)

    # Fix "There's no line here to end": font-only group followed by \\
    # e.g. {\fontsize{...}\selectfont\heiti\bfseries }\\[1em]
    # When Jinja2 variables render empty, only font commands remain.
    # Insert ~ before closing } so \\ has content to end.
    content = re.sub(
        r'(\\(?:bfseries|normalfont|itshape|mdseries|selectfont|heiti|songti|fangsong|kaiti))\s*\}(\\\\)',
        r'\1~}\2',
        content,
    )

    # Auto-inject missing packages that LLM-generated content commonly needs
    content = _inject_missing_packages(content)

    # Deduplicate \label{} to prevent "multiply-defined labels" errors
    content = _dedup_labels(content)

    # Fix truncated LaTeX: close unclosed environments and ensure \end{document}
    content = _fix_truncated_latex(content)

    return content


def _inject_missing_packages(content: str) -> str:
    """Auto-inject commonly needed packages when used but not loaded."""
    if r'\begin{document}' not in content:
        return content

    # Map: (command/env used in body) → package to inject
    _PACKAGE_TRIGGERS = [
        (r'\toprule', 'booktabs'),
        (r'\midrule', 'booktabs'),
        (r'\bottomrule', 'booktabs'),
        (r'\begin{longtable}', 'longtable'),
        (r'\begin{tabularx}', 'tabularx'),
        (r'\begin{multirow}', 'multirow'),
        (r'\multirow{', 'multirow'),
        (r'\multicolumn{', 'multicol'),
    ]

    doc_idx = content.index(r'\begin{document}')
    preamble = content[:doc_idx]
    body = content[doc_idx:]

    injections = []
    for trigger, pkg in _PACKAGE_TRIGGERS:
        if trigger in body and f'\\usepackage{{{pkg}}}' not in preamble and f'{{{pkg}}}' not in preamble:
            injections.append(f'\\usepackage{{{pkg}}}')

    if not injections:
        return content

    # Insert before \begin{document}
    inject_str = '\n'.join(dict.fromkeys(injections))  # deduplicate
    return preamble.rstrip() + '\n' + inject_str + '\n' + body


def _dedup_labels(content: str) -> str:
    """Detect duplicate \\label{} and auto-suffix to prevent LaTeX errors."""
    seen: dict[str, int] = {}

    def replace_label(m: re.Match) -> str:
        label = m.group(1)
        seen[label] = seen.get(label, 0) + 1
        if seen[label] == 1:
            return m.group(0)
        return f'\\label{{{label}_{seen[label]}}}'

    return re.sub(r'\\label\{([^}]+)\}', replace_label, content)


def _fix_centering_in_tabularx(content: str) -> str:
    """Fix \\centering inside tabularx that breaks \\\\ row endings.

    In tabularx X columns (paragraph mode), \\centering redefines \\\\ to
    \\newline instead of \\tabularnewline, causing 'Misplaced \\noalign'
    errors when \\hline follows. Fix by appending \\arraybackslash after
    \\centering inside tabularx environments.
    """
    def fix_tabularx_block(m: re.Match) -> str:
        block = m.group(0)
        # Add \arraybackslash after bare \centering (not already followed by it)
        block = re.sub(
            r'\\centering(?!\\arraybackslash)',
            r'\\centering\\arraybackslash',
            block,
        )
        return block

    content = re.sub(
        r'\\begin\{tabularx\}.*?\\end\{tabularx\}',
        fix_tabularx_block,
        content,
        flags=re.DOTALL,
    )
    return content


def _fix_truncated_latex(content: str) -> str:
    """Detect and repair truncated LaTeX output from LLM."""
    # Track open environments
    open_envs: list[str] = []
    for m in re.finditer(r'\\(begin|end)\{([^}]+)\}', content):
        action, env_name = m.group(1), m.group(2)
        if action == 'begin':
            open_envs.append(env_name)
        elif action == 'end' and open_envs and open_envs[-1] == env_name:
            open_envs.pop()

    # If there are unclosed environments, close them in reverse order
    if open_envs:
        # Remove 'document' from the list — we'll handle it separately
        has_document = False
        closings = []
        for env in reversed(open_envs):
            if env == 'document':
                has_document = True
            else:
                closings.append(f'\\end{{{env}}}')

        if closings:
            content = content.rstrip() + '\n' + '\n'.join(closings) + '\n'

        # Ensure \end{document} is present
        if has_document and '\\end{document}' not in content:
            content = content.rstrip() + '\n\\end{document}\n'
    elif '\\begin{document}' in content and '\\end{document}' not in content:
        content = content.rstrip() + '\n\\end{document}\n'

    return content


def _build_tex_env() -> dict[str, str]:
    """Build environment dict with TeX binaries in PATH, cross-platform."""
    env = {**os.environ}
    tex_bin = "/Library/TeX/texbin"
    if platform.system() != "Windows" and Path(tex_bin).is_dir():
        env["PATH"] = f"{tex_bin}{os.pathsep}{env.get('PATH', '')}"
    return env


async def _run_subprocess(
    cmd_args: list[str],
    cwd: str,
    env: dict[str, str],
    timeout: float,
) -> tuple[int, str, str]:
    """Run a subprocess with Windows-compatible fallback.

    On Windows with SelectorEventLoop, asyncio.create_subprocess_exec raises
    NotImplementedError. Falls back to subprocess.run in a thread.
    """
    try:
        process = await asyncio.create_subprocess_exec(
            *cmd_args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=cwd,
            env=env,
        )
        stdout, stderr = await asyncio.wait_for(
            process.communicate(), timeout=timeout,
        )
        return (
            process.returncode or 0,
            stdout.decode("utf-8", errors="replace"),
            stderr.decode("utf-8", errors="replace"),
        )
    except NotImplementedError:
        logger.debug(
            "asyncio subprocess not supported on this event loop, using sync fallback"
        )
        try:
            result = await asyncio.to_thread(
                subprocess.run,
                cmd_args,
                capture_output=True,
                cwd=cwd,
                env=env,
                timeout=timeout,
            )
            return (
                result.returncode,
                result.stdout.decode("utf-8", errors="replace"),
                result.stderr.decode("utf-8", errors="replace"),
            )
        except subprocess.TimeoutExpired:
            raise asyncio.TimeoutError()


def _copy_support_dirs(support_dirs: list[Path], target_dir: Path) -> None:
    """Copy support directories (cls/sty/bst etc.) into the compilation target."""
    for src_dir in support_dirs:
        dst = target_dir / src_dir.name
        if dst.exists():
            shutil.rmtree(dst)
        shutil.copytree(src_dir, dst)


async def compile_latex(
    latex_content: str,
    output_dir: Path,
    support_dirs: list[Path] | None = None,
) -> CompileResult:
    """Compile LaTeX content to PDF using latexmk + xelatex."""
    output_dir.mkdir(parents=True, exist_ok=True)
    if support_dirs:
        _copy_support_dirs(support_dirs, output_dir)
    latex_content = _fix_common_latex_issues(latex_content)
    tex_path = output_dir / "document.tex"
    tex_path.write_text(latex_content, encoding="utf-8")

    env = _build_tex_env()

    # `-xelatex` is a latexmk flag (select xelatex engine); when the user
    # configures LATEX_CMD to call xelatex/lualatex directly, omit it.
    is_latexmk = "latexmk" in Path(settings.LATEX_CMD).name
    cmd_args = [settings.LATEX_CMD]
    if is_latexmk:
        cmd_args.append("-xelatex")
    cmd_args += ["-synctex=1", "-interaction=nonstopmode", "-no-shell-escape", "document.tex"]
    logger.info("compile_latex: cmd=%s  cwd=%s", " ".join(cmd_args), output_dir)
    logger.debug("compile_latex: PATH=%s", env.get("PATH", ""))

    try:
        returncode, log_text, err_text = await _run_subprocess(
            cmd_args, cwd=str(output_dir), env=env, timeout=60,
        )
        full_log = log_text + "\n" + err_text

        logger.debug("compile_latex: return_code=%s  log_length=%d", returncode, len(full_log))

        pdf_path = output_dir / "document.pdf"
        if returncode == 0 and pdf_path.exists():
            logger.info("compile_latex: success, pdf=%s", pdf_path)
            return CompileResult(
                success=True,
                pdf_path=str(pdf_path),
                log=full_log,
            )

        # latexmk failed but may have produced a PDF with partial content.
        # Record the mtime BEFORE writing .tex so we can detect stale PDFs.
        errors = _extract_errors(full_log)
        if pdf_path.exists() and tex_path.exists():
            pdf_mtime = pdf_path.stat().st_mtime
            tex_mtime = tex_path.stat().st_mtime
            if pdf_mtime >= tex_mtime:
                # PDF was updated during this run — return it with warnings
                logger.warning(
                    "compile_latex: latexmk returned %s but PDF was updated, treating as partial success. errors=%s",
                    returncode, errors[:3],
                )
                return CompileResult(
                    success=True,
                    pdf_path=str(pdf_path),
                    log=full_log,
                    errors=errors,
                )
            else:
                logger.warning(
                    "compile_latex: failed (rc=%s), PDF is stale. errors=%s",
                    returncode, errors[:5],
                )
        else:
            logger.warning("compile_latex: failed, errors=%s", errors[:5])
        logger.debug("compile_latex: full log\n%s", full_log[-3000:])
        return CompileResult(
            success=False,
            log=full_log,
            errors=errors if errors else ["PDF file was not generated."],
        )

    except asyncio.TimeoutError:
        logger.error("compile_latex: timed out (60s)  cwd=%s", output_dir)
        return CompileResult(
            success=False,
            log="Compilation timed out after 60 seconds.",
            errors=["Compilation timed out."],
        )
    except FileNotFoundError:
        logger.error("compile_latex: command not found: %s", settings.LATEX_CMD)
        return CompileResult(
            success=False,
            log=f"Command '{settings.LATEX_CMD}' not found.",
            errors=[f"LaTeX compiler '{settings.LATEX_CMD}' is not installed or not in PATH."],
        )


async def validate_latex_syntax(
    latex_content: str,
    support_dirs: list[Path] | None = None,
) -> CompileResult:
    """Quick syntax validation using xelatex -draftmode (no PDF output).

    Much faster than full compilation — only checks syntax without generating
    any output file. Used to validate individual chapters before assembly.
    """
    import tempfile

    work_dir = Path(tempfile.mkdtemp(prefix="latex_validate_"))

    try:
        if support_dirs:
            _copy_support_dirs(support_dirs, work_dir)
        latex_content = _fix_common_latex_issues(latex_content)
        tex_path = work_dir / "validate.tex"
        tex_path.write_text(latex_content, encoding="utf-8")

        env = _build_tex_env()

        cmd_args = [
            "xelatex", "-draftmode", "-interaction=nonstopmode",
            "-no-shell-escape", "-halt-on-error", "validate.tex",
        ]
        logger.info("validate_latex_syntax: cmd=%s  cwd=%s", " ".join(cmd_args), work_dir)
        logger.debug("validate_latex_syntax: PATH=%s", env.get("PATH", ""))

        try:
            returncode, log_text, err_text = await _run_subprocess(
                cmd_args, cwd=str(work_dir), env=env, timeout=30,
            )
            full_log = log_text + "\n" + err_text

            errors = _extract_errors(full_log)
            if errors:
                logger.warning("validate_latex_syntax: errors=%s", errors[:5])
            else:
                logger.debug("validate_latex_syntax: ok, return_code=%s", returncode)
            return CompileResult(
                success=returncode == 0,
                log=full_log,
                errors=errors,
            )
        except asyncio.TimeoutError:
            logger.error("validate_latex_syntax: timed out (30s)  cwd=%s", work_dir)
            return CompileResult(
                success=False,
                log="Validation timed out after 30 seconds.",
                errors=["Validation timed out."],
            )
        except FileNotFoundError:
            logger.error("validate_latex_syntax: xelatex not found in PATH")
            return CompileResult(
                success=False,
                log="xelatex not found.",
                errors=["xelatex is not installed or not in PATH."],
            )
    finally:
        shutil.rmtree(work_dir, ignore_errors=True)


def _extract_errors(log: str) -> list[str]:
    errors = []
    for line in log.split("\n"):
        if line.startswith("!") or "Error" in line:
            errors.append(line.strip())
    return errors
